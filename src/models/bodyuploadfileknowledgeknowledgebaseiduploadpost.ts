/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { blobLikeSchema } from "../types/blobs.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

export type BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost = {
  /**
   * The file to upload
   */
  file: BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile | Blob;
  /**
   * The chunk size to use for the document (number of characters)
   */
  textProcessingChunkSize?: number | undefined;
  /**
   * The chunk overlap to use for the document (number of characters)
   */
  textProcessingChunkOverlap?: number | undefined;
  /**
   * Optional JSON object metadata to attach to the file
   */
  metadata?: string | null | undefined;
};

/** @internal */
export const BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$inboundSchema:
  z.ZodType<
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile,
    z.ZodTypeDef,
    unknown
  > = z.object({
    fileName: z.string(),
    content: z.union([
      z.instanceof(ReadableStream<Uint8Array>),
      z.instanceof(Blob),
      z.instanceof(ArrayBuffer),
      z.instanceof(Uint8Array),
    ]),
  });
/** @internal */
export type BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$outboundSchema:
  z.ZodType<
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$Outbound,
    z.ZodTypeDef,
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile
  > = z.object({
    fileName: z.string(),
    content: z.union([
      z.instanceof(ReadableStream<Uint8Array>),
      z.instanceof(Blob),
      z.instanceof(ArrayBuffer),
      z.instanceof(Uint8Array),
    ]),
  });

export function bodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFileToJSON(
  bodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile:
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile,
): string {
  return JSON.stringify(
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$outboundSchema.parse(
      bodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile,
    ),
  );
}
export function bodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFileFromJSON(
  jsonString: string,
): SafeParseResult<
  BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile' from JSON`,
  );
}

/** @internal */
export const BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost$inboundSchema:
  z.ZodType<
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    file: z.lazy(() =>
      BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$inboundSchema
    ),
    "text_processing.chunk_size": z.number().int().default(2000),
    "text_processing.chunk_overlap": z.number().int().default(200),
    metadata: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "text_processing.chunk_size": "textProcessingChunkSize",
      "text_processing.chunk_overlap": "textProcessingChunkOverlap",
    });
  });
/** @internal */
export type BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost$Outbound = {
  file: BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$Outbound | Blob;
  "text_processing.chunk_size": number;
  "text_processing.chunk_overlap": number;
  metadata?: string | null | undefined;
};

/** @internal */
export const BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost$outboundSchema:
  z.ZodType<
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost$Outbound,
    z.ZodTypeDef,
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost
  > = z.object({
    file: z.lazy(() =>
      BodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFile$outboundSchema
    ).or(blobLikeSchema),
    textProcessingChunkSize: z.number().int().default(2000),
    textProcessingChunkOverlap: z.number().int().default(200),
    metadata: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      textProcessingChunkSize: "text_processing.chunk_size",
      textProcessingChunkOverlap: "text_processing.chunk_overlap",
    });
  });

export function bodyUploadFileKnowledgeKnowledgeBaseIdUploadPostToJSON(
  bodyUploadFileKnowledgeKnowledgeBaseIdUploadPost:
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost,
): string {
  return JSON.stringify(
    BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost$outboundSchema.parse(
      bodyUploadFileKnowledgeKnowledgeBaseIdUploadPost,
    ),
  );
}
export function bodyUploadFileKnowledgeKnowledgeBaseIdUploadPostFromJSON(
  jsonString: string,
): SafeParseResult<
  BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BodyUploadFileKnowledgeKnowledgeBaseIdUploadPost' from JSON`,
  );
}
