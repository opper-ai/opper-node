/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Result of the task if the call uses an output schema
 */
export type JsonPayload = { [k: string]: any } | Array<any> | any;

export type CallFunctionResponse = {
  /**
   * The ID of the span of the call
   */
  spanId: string;
  /**
   * Result of the task if the call does not use an output schema
   */
  message?: string | null | undefined;
  /**
   * Result of the task if the call uses an output schema
   */
  jsonPayload?: { [k: string]: any } | Array<any> | any | null | undefined;
  /**
   * True if the result was returned from a cached results
   */
  cached?: boolean | null | undefined;
  /**
   * The images generated by the call. Only available for image models. Depending on the configuration, the response can either be a list of image urls or a base64 encoded images.
   */
  images?: Array<string> | null | undefined;
  /**
   * The usage of the call split into input and output tokens as well as the total tokens and an optional breakdown of the input and output tokens.The input tokens are the tokens sent to the model and the output tokens are the tokens received from the model. The total tokens is the sum of input and output tokens.
   */
  usage?: { [k: string]: any } | null | undefined;
  /**
   * The cost in USD of the call split into total, generation and platform costs where total is the sum of generation and platform costs
   */
  cost?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const JsonPayload$inboundSchema: z.ZodType<
  JsonPayload,
  z.ZodTypeDef,
  unknown
> = z.union([z.record(z.any()), z.array(z.any()), z.any()]);
/** @internal */
export type JsonPayload$Outbound = { [k: string]: any } | Array<any> | any;

/** @internal */
export const JsonPayload$outboundSchema: z.ZodType<
  JsonPayload$Outbound,
  z.ZodTypeDef,
  JsonPayload
> = z.union([z.record(z.any()), z.array(z.any()), z.any()]);

export function jsonPayloadToJSON(jsonPayload: JsonPayload): string {
  return JSON.stringify(JsonPayload$outboundSchema.parse(jsonPayload));
}
export function jsonPayloadFromJSON(
  jsonString: string,
): SafeParseResult<JsonPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JsonPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JsonPayload' from JSON`,
  );
}

/** @internal */
export const CallFunctionResponse$inboundSchema: z.ZodType<
  CallFunctionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  span_id: z.string(),
  message: z.nullable(z.string()).optional(),
  json_payload: z.nullable(
    z.union([z.record(z.any()), z.array(z.any()), z.any()]),
  ).optional(),
  cached: z.nullable(z.boolean()).optional(),
  images: z.nullable(z.array(z.string())).optional(),
  usage: z.nullable(z.record(z.any())).optional(),
  cost: z.nullable(z.record(z.any())).optional(),
}).transform((v) => {
  return remap$(v, {
    "span_id": "spanId",
    "json_payload": "jsonPayload",
  });
});
/** @internal */
export type CallFunctionResponse$Outbound = {
  span_id: string;
  message?: string | null | undefined;
  json_payload?: { [k: string]: any } | Array<any> | any | null | undefined;
  cached?: boolean | null | undefined;
  images?: Array<string> | null | undefined;
  usage?: { [k: string]: any } | null | undefined;
  cost?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const CallFunctionResponse$outboundSchema: z.ZodType<
  CallFunctionResponse$Outbound,
  z.ZodTypeDef,
  CallFunctionResponse
> = z.object({
  spanId: z.string(),
  message: z.nullable(z.string()).optional(),
  jsonPayload: z.nullable(
    z.union([z.record(z.any()), z.array(z.any()), z.any()]),
  ).optional(),
  cached: z.nullable(z.boolean()).optional(),
  images: z.nullable(z.array(z.string())).optional(),
  usage: z.nullable(z.record(z.any())).optional(),
  cost: z.nullable(z.record(z.any())).optional(),
}).transform((v) => {
  return remap$(v, {
    spanId: "span_id",
    jsonPayload: "json_payload",
  });
});

export function callFunctionResponseToJSON(
  callFunctionResponse: CallFunctionResponse,
): string {
  return JSON.stringify(
    CallFunctionResponse$outboundSchema.parse(callFunctionResponse),
  );
}
export function callFunctionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CallFunctionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CallFunctionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CallFunctionResponse' from JSON`,
  );
}
