/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  FunctionCallConfiguration,
  FunctionCallConfiguration$inboundSchema,
  FunctionCallConfiguration$Outbound,
  FunctionCallConfiguration$outboundSchema,
} from "./functioncallconfiguration.js";
import {
  TModel,
  TModel$inboundSchema,
  TModel$Outbound,
  TModel$outboundSchema,
} from "./tmodel.js";

export type CreateFunctionResponse = {
  /**
   * The name of the function. Must be unique within the project and can only contain letters, numbers, underscores and hyphens.
   */
  name: string;
  /**
   * Optional description of the function. This is used to describe the function to a user.
   */
  description?: string | null | undefined;
  /**
   * The instructions for the function, this is the prompt that will be sent to the model to complete the task. Recommended to be concise and to the point
   */
  instructions: string;
  /**
   * Optional input schema for the function. Can preferably include field descriptions to allow the model to reason about the input variables. Schema is validated against the input data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
   */
  inputSchema?: { [k: string]: any } | null | undefined;
  /**
   * Optional output schema for the function. Can preferably include field descriptions to allow the model to reason about the output variables. Schema is validated against the output data and issues an error if it does not match. With the Opper SDKs you can define these schemas through libraries like Pydantic and Zod. For schemas with definitions, prefer using '$defs' and '#/$defs/...' references.
   */
  outputSchema?: { [k: string]: any } | null | undefined;
  model?: TModel | undefined;
  /**
   * Optional configuration for the function.Configuration is a dictionary of key-value pairs that can be used to override the default configuration for the function.
   */
  configuration?: FunctionCallConfiguration | null | undefined;
  /**
   * The ID of the function
   */
  id: string;
  /**
   * The ID of the dataset associated with the function
   */
  datasetId?: string | null | undefined;
  /**
   * The ID of the latest revision of the function
   */
  revisionId?: string | null | undefined;
};

/** @internal */
export const CreateFunctionResponse$inboundSchema: z.ZodType<
  CreateFunctionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  instructions: z.string(),
  input_schema: z.nullable(z.record(z.any())).optional(),
  output_schema: z.nullable(z.record(z.any())).optional(),
  model: TModel$inboundSchema.optional(),
  configuration: z.nullable(FunctionCallConfiguration$inboundSchema).optional(),
  id: z.string(),
  dataset_id: z.nullable(z.string()).optional(),
  revision_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "input_schema": "inputSchema",
    "output_schema": "outputSchema",
    "dataset_id": "datasetId",
    "revision_id": "revisionId",
  });
});

/** @internal */
export type CreateFunctionResponse$Outbound = {
  name: string;
  description?: string | null | undefined;
  instructions: string;
  input_schema?: { [k: string]: any } | null | undefined;
  output_schema?: { [k: string]: any } | null | undefined;
  model?: TModel$Outbound | undefined;
  configuration?: FunctionCallConfiguration$Outbound | null | undefined;
  id: string;
  dataset_id?: string | null | undefined;
  revision_id?: string | null | undefined;
};

/** @internal */
export const CreateFunctionResponse$outboundSchema: z.ZodType<
  CreateFunctionResponse$Outbound,
  z.ZodTypeDef,
  CreateFunctionResponse
> = z.object({
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  instructions: z.string(),
  inputSchema: z.nullable(z.record(z.any())).optional(),
  outputSchema: z.nullable(z.record(z.any())).optional(),
  model: TModel$outboundSchema.optional(),
  configuration: z.nullable(FunctionCallConfiguration$outboundSchema)
    .optional(),
  id: z.string(),
  datasetId: z.nullable(z.string()).optional(),
  revisionId: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    inputSchema: "input_schema",
    outputSchema: "output_schema",
    datasetId: "dataset_id",
    revisionId: "revision_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateFunctionResponse$ {
  /** @deprecated use `CreateFunctionResponse$inboundSchema` instead. */
  export const inboundSchema = CreateFunctionResponse$inboundSchema;
  /** @deprecated use `CreateFunctionResponse$outboundSchema` instead. */
  export const outboundSchema = CreateFunctionResponse$outboundSchema;
  /** @deprecated use `CreateFunctionResponse$Outbound` instead. */
  export type Outbound = CreateFunctionResponse$Outbound;
}

export function createFunctionResponseToJSON(
  createFunctionResponse: CreateFunctionResponse,
): string {
  return JSON.stringify(
    CreateFunctionResponse$outboundSchema.parse(createFunctionResponse),
  );
}

export function createFunctionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateFunctionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateFunctionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateFunctionResponse' from JSON`,
  );
}
