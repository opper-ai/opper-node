// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/types"
	"mockserver/internal/sdk/utils"
)

type ChatCompletionNonStreamingMessageType string

const (
	ChatCompletionNonStreamingMessageTypeChatCompletionDeveloperMessageParam ChatCompletionNonStreamingMessageType = "ChatCompletionDeveloperMessageParam"
	ChatCompletionNonStreamingMessageTypeChatCompletionSystemMessageParam    ChatCompletionNonStreamingMessageType = "ChatCompletionSystemMessageParam"
	ChatCompletionNonStreamingMessageTypeChatCompletionUserMessageParam      ChatCompletionNonStreamingMessageType = "ChatCompletionUserMessageParam"
	ChatCompletionNonStreamingMessageTypeChatCompletionAssistantMessageParam ChatCompletionNonStreamingMessageType = "ChatCompletionAssistantMessageParam"
	ChatCompletionNonStreamingMessageTypeChatCompletionToolMessageParam      ChatCompletionNonStreamingMessageType = "ChatCompletionToolMessageParam"
	ChatCompletionNonStreamingMessageTypeChatCompletionFunctionMessageParam  ChatCompletionNonStreamingMessageType = "ChatCompletionFunctionMessageParam"
)

type ChatCompletionNonStreamingMessage struct {
	ChatCompletionDeveloperMessageParam *ChatCompletionDeveloperMessageParam `queryParam:"inline"`
	ChatCompletionSystemMessageParam    *ChatCompletionSystemMessageParam    `queryParam:"inline"`
	ChatCompletionUserMessageParam      *ChatCompletionUserMessageParam      `queryParam:"inline"`
	ChatCompletionAssistantMessageParam *ChatCompletionAssistantMessageParam `queryParam:"inline"`
	ChatCompletionToolMessageParam      *ChatCompletionToolMessageParam      `queryParam:"inline"`
	ChatCompletionFunctionMessageParam  *ChatCompletionFunctionMessageParam  `queryParam:"inline"`

	Type ChatCompletionNonStreamingMessageType
}

func CreateChatCompletionNonStreamingMessageChatCompletionDeveloperMessageParam(chatCompletionDeveloperMessageParam ChatCompletionDeveloperMessageParam) ChatCompletionNonStreamingMessage {
	typ := ChatCompletionNonStreamingMessageTypeChatCompletionDeveloperMessageParam

	return ChatCompletionNonStreamingMessage{
		ChatCompletionDeveloperMessageParam: &chatCompletionDeveloperMessageParam,
		Type:                                typ,
	}
}

func CreateChatCompletionNonStreamingMessageChatCompletionSystemMessageParam(chatCompletionSystemMessageParam ChatCompletionSystemMessageParam) ChatCompletionNonStreamingMessage {
	typ := ChatCompletionNonStreamingMessageTypeChatCompletionSystemMessageParam

	return ChatCompletionNonStreamingMessage{
		ChatCompletionSystemMessageParam: &chatCompletionSystemMessageParam,
		Type:                             typ,
	}
}

func CreateChatCompletionNonStreamingMessageChatCompletionUserMessageParam(chatCompletionUserMessageParam ChatCompletionUserMessageParam) ChatCompletionNonStreamingMessage {
	typ := ChatCompletionNonStreamingMessageTypeChatCompletionUserMessageParam

	return ChatCompletionNonStreamingMessage{
		ChatCompletionUserMessageParam: &chatCompletionUserMessageParam,
		Type:                           typ,
	}
}

func CreateChatCompletionNonStreamingMessageChatCompletionAssistantMessageParam(chatCompletionAssistantMessageParam ChatCompletionAssistantMessageParam) ChatCompletionNonStreamingMessage {
	typ := ChatCompletionNonStreamingMessageTypeChatCompletionAssistantMessageParam

	return ChatCompletionNonStreamingMessage{
		ChatCompletionAssistantMessageParam: &chatCompletionAssistantMessageParam,
		Type:                                typ,
	}
}

func CreateChatCompletionNonStreamingMessageChatCompletionToolMessageParam(chatCompletionToolMessageParam ChatCompletionToolMessageParam) ChatCompletionNonStreamingMessage {
	typ := ChatCompletionNonStreamingMessageTypeChatCompletionToolMessageParam

	return ChatCompletionNonStreamingMessage{
		ChatCompletionToolMessageParam: &chatCompletionToolMessageParam,
		Type:                           typ,
	}
}

func CreateChatCompletionNonStreamingMessageChatCompletionFunctionMessageParam(chatCompletionFunctionMessageParam ChatCompletionFunctionMessageParam) ChatCompletionNonStreamingMessage {
	typ := ChatCompletionNonStreamingMessageTypeChatCompletionFunctionMessageParam

	return ChatCompletionNonStreamingMessage{
		ChatCompletionFunctionMessageParam: &chatCompletionFunctionMessageParam,
		Type:                               typ,
	}
}

func (u *ChatCompletionNonStreamingMessage) UnmarshalJSON(data []byte) error {

	var chatCompletionDeveloperMessageParam ChatCompletionDeveloperMessageParam = ChatCompletionDeveloperMessageParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionDeveloperMessageParam, "", true, true); err == nil {
		u.ChatCompletionDeveloperMessageParam = &chatCompletionDeveloperMessageParam
		u.Type = ChatCompletionNonStreamingMessageTypeChatCompletionDeveloperMessageParam
		return nil
	}

	var chatCompletionSystemMessageParam ChatCompletionSystemMessageParam = ChatCompletionSystemMessageParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionSystemMessageParam, "", true, true); err == nil {
		u.ChatCompletionSystemMessageParam = &chatCompletionSystemMessageParam
		u.Type = ChatCompletionNonStreamingMessageTypeChatCompletionSystemMessageParam
		return nil
	}

	var chatCompletionUserMessageParam ChatCompletionUserMessageParam = ChatCompletionUserMessageParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionUserMessageParam, "", true, true); err == nil {
		u.ChatCompletionUserMessageParam = &chatCompletionUserMessageParam
		u.Type = ChatCompletionNonStreamingMessageTypeChatCompletionUserMessageParam
		return nil
	}

	var chatCompletionToolMessageParam ChatCompletionToolMessageParam = ChatCompletionToolMessageParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionToolMessageParam, "", true, true); err == nil {
		u.ChatCompletionToolMessageParam = &chatCompletionToolMessageParam
		u.Type = ChatCompletionNonStreamingMessageTypeChatCompletionToolMessageParam
		return nil
	}

	var chatCompletionFunctionMessageParam ChatCompletionFunctionMessageParam = ChatCompletionFunctionMessageParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionFunctionMessageParam, "", true, true); err == nil {
		u.ChatCompletionFunctionMessageParam = &chatCompletionFunctionMessageParam
		u.Type = ChatCompletionNonStreamingMessageTypeChatCompletionFunctionMessageParam
		return nil
	}

	var chatCompletionAssistantMessageParam ChatCompletionAssistantMessageParam = ChatCompletionAssistantMessageParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionAssistantMessageParam, "", true, true); err == nil {
		u.ChatCompletionAssistantMessageParam = &chatCompletionAssistantMessageParam
		u.Type = ChatCompletionNonStreamingMessageTypeChatCompletionAssistantMessageParam
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatCompletionNonStreamingMessage", string(data))
}

func (u ChatCompletionNonStreamingMessage) MarshalJSON() ([]byte, error) {
	if u.ChatCompletionDeveloperMessageParam != nil {
		return utils.MarshalJSON(u.ChatCompletionDeveloperMessageParam, "", true)
	}

	if u.ChatCompletionSystemMessageParam != nil {
		return utils.MarshalJSON(u.ChatCompletionSystemMessageParam, "", true)
	}

	if u.ChatCompletionUserMessageParam != nil {
		return utils.MarshalJSON(u.ChatCompletionUserMessageParam, "", true)
	}

	if u.ChatCompletionAssistantMessageParam != nil {
		return utils.MarshalJSON(u.ChatCompletionAssistantMessageParam, "", true)
	}

	if u.ChatCompletionToolMessageParam != nil {
		return utils.MarshalJSON(u.ChatCompletionToolMessageParam, "", true)
	}

	if u.ChatCompletionFunctionMessageParam != nil {
		return utils.MarshalJSON(u.ChatCompletionFunctionMessageParam, "", true)
	}

	return nil, errors.New("could not marshal union type ChatCompletionNonStreamingMessage: all fields are null")
}

type ChatCompletionNonStreamingFunctionCallEnum string

const (
	ChatCompletionNonStreamingFunctionCallEnumNone ChatCompletionNonStreamingFunctionCallEnum = "none"
	ChatCompletionNonStreamingFunctionCallEnumAuto ChatCompletionNonStreamingFunctionCallEnum = "auto"
)

func (e ChatCompletionNonStreamingFunctionCallEnum) ToPointer() *ChatCompletionNonStreamingFunctionCallEnum {
	return &e
}
func (e *ChatCompletionNonStreamingFunctionCallEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "auto":
		*e = ChatCompletionNonStreamingFunctionCallEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChatCompletionNonStreamingFunctionCallEnum: %v", v)
	}
}

type ChatCompletionNonStreamingFunctionCallUnionType string

const (
	ChatCompletionNonStreamingFunctionCallUnionTypeChatCompletionNonStreamingFunctionCallEnum ChatCompletionNonStreamingFunctionCallUnionType = "ChatCompletionNonStreaming_Function Call_enum"
	ChatCompletionNonStreamingFunctionCallUnionTypeChatCompletionFunctionCallOptionParam      ChatCompletionNonStreamingFunctionCallUnionType = "ChatCompletionFunctionCallOptionParam"
)

type ChatCompletionNonStreamingFunctionCallUnion struct {
	ChatCompletionNonStreamingFunctionCallEnum *ChatCompletionNonStreamingFunctionCallEnum `queryParam:"inline"`
	ChatCompletionFunctionCallOptionParam      *ChatCompletionFunctionCallOptionParam      `queryParam:"inline"`

	Type ChatCompletionNonStreamingFunctionCallUnionType
}

func CreateChatCompletionNonStreamingFunctionCallUnionChatCompletionNonStreamingFunctionCallEnum(chatCompletionNonStreamingFunctionCallEnum ChatCompletionNonStreamingFunctionCallEnum) ChatCompletionNonStreamingFunctionCallUnion {
	typ := ChatCompletionNonStreamingFunctionCallUnionTypeChatCompletionNonStreamingFunctionCallEnum

	return ChatCompletionNonStreamingFunctionCallUnion{
		ChatCompletionNonStreamingFunctionCallEnum: &chatCompletionNonStreamingFunctionCallEnum,
		Type: typ,
	}
}

func CreateChatCompletionNonStreamingFunctionCallUnionChatCompletionFunctionCallOptionParam(chatCompletionFunctionCallOptionParam ChatCompletionFunctionCallOptionParam) ChatCompletionNonStreamingFunctionCallUnion {
	typ := ChatCompletionNonStreamingFunctionCallUnionTypeChatCompletionFunctionCallOptionParam

	return ChatCompletionNonStreamingFunctionCallUnion{
		ChatCompletionFunctionCallOptionParam: &chatCompletionFunctionCallOptionParam,
		Type:                                  typ,
	}
}

func (u *ChatCompletionNonStreamingFunctionCallUnion) UnmarshalJSON(data []byte) error {

	var chatCompletionFunctionCallOptionParam ChatCompletionFunctionCallOptionParam = ChatCompletionFunctionCallOptionParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionFunctionCallOptionParam, "", true, true); err == nil {
		u.ChatCompletionFunctionCallOptionParam = &chatCompletionFunctionCallOptionParam
		u.Type = ChatCompletionNonStreamingFunctionCallUnionTypeChatCompletionFunctionCallOptionParam
		return nil
	}

	var chatCompletionNonStreamingFunctionCallEnum ChatCompletionNonStreamingFunctionCallEnum = ChatCompletionNonStreamingFunctionCallEnum("")
	if err := utils.UnmarshalJSON(data, &chatCompletionNonStreamingFunctionCallEnum, "", true, true); err == nil {
		u.ChatCompletionNonStreamingFunctionCallEnum = &chatCompletionNonStreamingFunctionCallEnum
		u.Type = ChatCompletionNonStreamingFunctionCallUnionTypeChatCompletionNonStreamingFunctionCallEnum
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatCompletionNonStreamingFunctionCallUnion", string(data))
}

func (u ChatCompletionNonStreamingFunctionCallUnion) MarshalJSON() ([]byte, error) {
	if u.ChatCompletionNonStreamingFunctionCallEnum != nil {
		return utils.MarshalJSON(u.ChatCompletionNonStreamingFunctionCallEnum, "", true)
	}

	if u.ChatCompletionFunctionCallOptionParam != nil {
		return utils.MarshalJSON(u.ChatCompletionFunctionCallOptionParam, "", true)
	}

	return nil, errors.New("could not marshal union type ChatCompletionNonStreamingFunctionCallUnion: all fields are null")
}

type ChatCompletionNonStreamingModality string

const (
	ChatCompletionNonStreamingModalityText  ChatCompletionNonStreamingModality = "text"
	ChatCompletionNonStreamingModalityAudio ChatCompletionNonStreamingModality = "audio"
)

func (e ChatCompletionNonStreamingModality) ToPointer() *ChatCompletionNonStreamingModality {
	return &e
}
func (e *ChatCompletionNonStreamingModality) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "audio":
		*e = ChatCompletionNonStreamingModality(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChatCompletionNonStreamingModality: %v", v)
	}
}

type ChatCompletionNonStreamingReasoningEffort string

const (
	ChatCompletionNonStreamingReasoningEffortLow    ChatCompletionNonStreamingReasoningEffort = "low"
	ChatCompletionNonStreamingReasoningEffortMedium ChatCompletionNonStreamingReasoningEffort = "medium"
	ChatCompletionNonStreamingReasoningEffortHigh   ChatCompletionNonStreamingReasoningEffort = "high"
)

func (e ChatCompletionNonStreamingReasoningEffort) ToPointer() *ChatCompletionNonStreamingReasoningEffort {
	return &e
}
func (e *ChatCompletionNonStreamingReasoningEffort) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "low":
		fallthrough
	case "medium":
		fallthrough
	case "high":
		*e = ChatCompletionNonStreamingReasoningEffort(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChatCompletionNonStreamingReasoningEffort: %v", v)
	}
}

type ChatCompletionNonStreamingResponseFormatType string

const (
	ChatCompletionNonStreamingResponseFormatTypeResponseFormatText       ChatCompletionNonStreamingResponseFormatType = "ResponseFormatText"
	ChatCompletionNonStreamingResponseFormatTypeResponseFormatJSONSchema ChatCompletionNonStreamingResponseFormatType = "ResponseFormatJSONSchema"
	ChatCompletionNonStreamingResponseFormatTypeResponseFormatJSONObject ChatCompletionNonStreamingResponseFormatType = "ResponseFormatJSONObject"
)

type ChatCompletionNonStreamingResponseFormat struct {
	ResponseFormatText       *ResponseFormatText       `queryParam:"inline"`
	ResponseFormatJSONSchema *ResponseFormatJSONSchema `queryParam:"inline"`
	ResponseFormatJSONObject *ResponseFormatJSONObject `queryParam:"inline"`

	Type ChatCompletionNonStreamingResponseFormatType
}

func CreateChatCompletionNonStreamingResponseFormatResponseFormatText(responseFormatText ResponseFormatText) ChatCompletionNonStreamingResponseFormat {
	typ := ChatCompletionNonStreamingResponseFormatTypeResponseFormatText

	return ChatCompletionNonStreamingResponseFormat{
		ResponseFormatText: &responseFormatText,
		Type:               typ,
	}
}

func CreateChatCompletionNonStreamingResponseFormatResponseFormatJSONSchema(responseFormatJSONSchema ResponseFormatJSONSchema) ChatCompletionNonStreamingResponseFormat {
	typ := ChatCompletionNonStreamingResponseFormatTypeResponseFormatJSONSchema

	return ChatCompletionNonStreamingResponseFormat{
		ResponseFormatJSONSchema: &responseFormatJSONSchema,
		Type:                     typ,
	}
}

func CreateChatCompletionNonStreamingResponseFormatResponseFormatJSONObject(responseFormatJSONObject ResponseFormatJSONObject) ChatCompletionNonStreamingResponseFormat {
	typ := ChatCompletionNonStreamingResponseFormatTypeResponseFormatJSONObject

	return ChatCompletionNonStreamingResponseFormat{
		ResponseFormatJSONObject: &responseFormatJSONObject,
		Type:                     typ,
	}
}

func (u *ChatCompletionNonStreamingResponseFormat) UnmarshalJSON(data []byte) error {

	var responseFormatText ResponseFormatText = ResponseFormatText{}
	if err := utils.UnmarshalJSON(data, &responseFormatText, "", true, true); err == nil {
		u.ResponseFormatText = &responseFormatText
		u.Type = ChatCompletionNonStreamingResponseFormatTypeResponseFormatText
		return nil
	}

	var responseFormatJSONObject ResponseFormatJSONObject = ResponseFormatJSONObject{}
	if err := utils.UnmarshalJSON(data, &responseFormatJSONObject, "", true, true); err == nil {
		u.ResponseFormatJSONObject = &responseFormatJSONObject
		u.Type = ChatCompletionNonStreamingResponseFormatTypeResponseFormatJSONObject
		return nil
	}

	var responseFormatJSONSchema ResponseFormatJSONSchema = ResponseFormatJSONSchema{}
	if err := utils.UnmarshalJSON(data, &responseFormatJSONSchema, "", true, true); err == nil {
		u.ResponseFormatJSONSchema = &responseFormatJSONSchema
		u.Type = ChatCompletionNonStreamingResponseFormatTypeResponseFormatJSONSchema
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatCompletionNonStreamingResponseFormat", string(data))
}

func (u ChatCompletionNonStreamingResponseFormat) MarshalJSON() ([]byte, error) {
	if u.ResponseFormatText != nil {
		return utils.MarshalJSON(u.ResponseFormatText, "", true)
	}

	if u.ResponseFormatJSONSchema != nil {
		return utils.MarshalJSON(u.ResponseFormatJSONSchema, "", true)
	}

	if u.ResponseFormatJSONObject != nil {
		return utils.MarshalJSON(u.ResponseFormatJSONObject, "", true)
	}

	return nil, errors.New("could not marshal union type ChatCompletionNonStreamingResponseFormat: all fields are null")
}

type ChatCompletionNonStreamingServiceTier string

const (
	ChatCompletionNonStreamingServiceTierAuto    ChatCompletionNonStreamingServiceTier = "auto"
	ChatCompletionNonStreamingServiceTierDefault ChatCompletionNonStreamingServiceTier = "default"
	ChatCompletionNonStreamingServiceTierFlex    ChatCompletionNonStreamingServiceTier = "flex"
)

func (e ChatCompletionNonStreamingServiceTier) ToPointer() *ChatCompletionNonStreamingServiceTier {
	return &e
}
func (e *ChatCompletionNonStreamingServiceTier) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "default":
		fallthrough
	case "flex":
		*e = ChatCompletionNonStreamingServiceTier(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChatCompletionNonStreamingServiceTier: %v", v)
	}
}

type ChatCompletionNonStreamingStopType string

const (
	ChatCompletionNonStreamingStopTypeStr        ChatCompletionNonStreamingStopType = "str"
	ChatCompletionNonStreamingStopTypeArrayOfStr ChatCompletionNonStreamingStopType = "arrayOfStr"
)

type ChatCompletionNonStreamingStop struct {
	Str        *string  `queryParam:"inline"`
	ArrayOfStr []string `queryParam:"inline"`

	Type ChatCompletionNonStreamingStopType
}

func CreateChatCompletionNonStreamingStopStr(str string) ChatCompletionNonStreamingStop {
	typ := ChatCompletionNonStreamingStopTypeStr

	return ChatCompletionNonStreamingStop{
		Str:  &str,
		Type: typ,
	}
}

func CreateChatCompletionNonStreamingStopArrayOfStr(arrayOfStr []string) ChatCompletionNonStreamingStop {
	typ := ChatCompletionNonStreamingStopTypeArrayOfStr

	return ChatCompletionNonStreamingStop{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *ChatCompletionNonStreamingStop) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ChatCompletionNonStreamingStopTypeStr
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, true); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = ChatCompletionNonStreamingStopTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatCompletionNonStreamingStop", string(data))
}

func (u ChatCompletionNonStreamingStop) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type ChatCompletionNonStreamingStop: all fields are null")
}

type ChatCompletionNonStreamingToolChoiceEnum string

const (
	ChatCompletionNonStreamingToolChoiceEnumNone     ChatCompletionNonStreamingToolChoiceEnum = "none"
	ChatCompletionNonStreamingToolChoiceEnumAuto     ChatCompletionNonStreamingToolChoiceEnum = "auto"
	ChatCompletionNonStreamingToolChoiceEnumRequired ChatCompletionNonStreamingToolChoiceEnum = "required"
)

func (e ChatCompletionNonStreamingToolChoiceEnum) ToPointer() *ChatCompletionNonStreamingToolChoiceEnum {
	return &e
}
func (e *ChatCompletionNonStreamingToolChoiceEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "auto":
		fallthrough
	case "required":
		*e = ChatCompletionNonStreamingToolChoiceEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChatCompletionNonStreamingToolChoiceEnum: %v", v)
	}
}

type ChatCompletionNonStreamingToolChoiceUnionType string

const (
	ChatCompletionNonStreamingToolChoiceUnionTypeChatCompletionNonStreamingToolChoiceEnum ChatCompletionNonStreamingToolChoiceUnionType = "ChatCompletionNonStreaming_Tool Choice_enum"
	ChatCompletionNonStreamingToolChoiceUnionTypeChatCompletionNamedToolChoiceParam       ChatCompletionNonStreamingToolChoiceUnionType = "ChatCompletionNamedToolChoiceParam"
)

type ChatCompletionNonStreamingToolChoiceUnion struct {
	ChatCompletionNonStreamingToolChoiceEnum *ChatCompletionNonStreamingToolChoiceEnum `queryParam:"inline"`
	ChatCompletionNamedToolChoiceParam       *ChatCompletionNamedToolChoiceParam       `queryParam:"inline"`

	Type ChatCompletionNonStreamingToolChoiceUnionType
}

func CreateChatCompletionNonStreamingToolChoiceUnionChatCompletionNonStreamingToolChoiceEnum(chatCompletionNonStreamingToolChoiceEnum ChatCompletionNonStreamingToolChoiceEnum) ChatCompletionNonStreamingToolChoiceUnion {
	typ := ChatCompletionNonStreamingToolChoiceUnionTypeChatCompletionNonStreamingToolChoiceEnum

	return ChatCompletionNonStreamingToolChoiceUnion{
		ChatCompletionNonStreamingToolChoiceEnum: &chatCompletionNonStreamingToolChoiceEnum,
		Type:                                     typ,
	}
}

func CreateChatCompletionNonStreamingToolChoiceUnionChatCompletionNamedToolChoiceParam(chatCompletionNamedToolChoiceParam ChatCompletionNamedToolChoiceParam) ChatCompletionNonStreamingToolChoiceUnion {
	typ := ChatCompletionNonStreamingToolChoiceUnionTypeChatCompletionNamedToolChoiceParam

	return ChatCompletionNonStreamingToolChoiceUnion{
		ChatCompletionNamedToolChoiceParam: &chatCompletionNamedToolChoiceParam,
		Type:                               typ,
	}
}

func (u *ChatCompletionNonStreamingToolChoiceUnion) UnmarshalJSON(data []byte) error {

	var chatCompletionNamedToolChoiceParam ChatCompletionNamedToolChoiceParam = ChatCompletionNamedToolChoiceParam{}
	if err := utils.UnmarshalJSON(data, &chatCompletionNamedToolChoiceParam, "", true, true); err == nil {
		u.ChatCompletionNamedToolChoiceParam = &chatCompletionNamedToolChoiceParam
		u.Type = ChatCompletionNonStreamingToolChoiceUnionTypeChatCompletionNamedToolChoiceParam
		return nil
	}

	var chatCompletionNonStreamingToolChoiceEnum ChatCompletionNonStreamingToolChoiceEnum = ChatCompletionNonStreamingToolChoiceEnum("")
	if err := utils.UnmarshalJSON(data, &chatCompletionNonStreamingToolChoiceEnum, "", true, true); err == nil {
		u.ChatCompletionNonStreamingToolChoiceEnum = &chatCompletionNonStreamingToolChoiceEnum
		u.Type = ChatCompletionNonStreamingToolChoiceUnionTypeChatCompletionNonStreamingToolChoiceEnum
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatCompletionNonStreamingToolChoiceUnion", string(data))
}

func (u ChatCompletionNonStreamingToolChoiceUnion) MarshalJSON() ([]byte, error) {
	if u.ChatCompletionNonStreamingToolChoiceEnum != nil {
		return utils.MarshalJSON(u.ChatCompletionNonStreamingToolChoiceEnum, "", true)
	}

	if u.ChatCompletionNamedToolChoiceParam != nil {
		return utils.MarshalJSON(u.ChatCompletionNamedToolChoiceParam, "", true)
	}

	return nil, errors.New("could not marshal union type ChatCompletionNonStreamingToolChoiceUnion: all fields are null")
}

type ChatCompletionNonStreaming struct {
	Messages            []ChatCompletionNonStreamingMessage             `json:"messages"`
	Model               *TModel                                         `json:"model,omitempty"`
	Audio               *ChatCompletionAudioParam                       `json:"audio,omitempty"`
	FrequencyPenalty    *float64                                        `json:"frequency_penalty,omitempty"`
	FunctionCall        *ChatCompletionNonStreamingFunctionCallUnion    `json:"function_call,omitempty"`
	Functions           []OpenaiTypesChatCompletionCreateParamsFunction `json:"functions,omitempty"`
	LogitBias           map[string]int64                                `json:"logit_bias,omitempty"`
	Logprobs            *bool                                           `json:"logprobs,omitempty"`
	MaxCompletionTokens *int64                                          `json:"max_completion_tokens,omitempty"`
	MaxTokens           *int64                                          `json:"max_tokens,omitempty"`
	Metadata            map[string]string                               `json:"metadata,omitempty"`
	Modalities          []ChatCompletionNonStreamingModality            `json:"modalities,omitempty"`
	N                   *int64                                          `json:"n,omitempty"`
	ParallelToolCalls   *bool                                           `json:"parallel_tool_calls,omitempty"`
	Prediction          *ChatCompletionPredictionContentParam           `json:"prediction,omitempty"`
	PresencePenalty     *float64                                        `json:"presence_penalty,omitempty"`
	ReasoningEffort     *ChatCompletionNonStreamingReasoningEffort      `json:"reasoning_effort,omitempty"`
	ResponseFormat      *ChatCompletionNonStreamingResponseFormat       `json:"response_format,omitempty"`
	Seed                *int64                                          `json:"seed,omitempty"`
	ServiceTier         *ChatCompletionNonStreamingServiceTier          `json:"service_tier,omitempty"`
	Stop                *ChatCompletionNonStreamingStop                 `json:"stop,omitempty"`
	Store               *bool                                           `json:"store,omitempty"`
	StreamOptions       *ChatCompletionStreamOptionsParam               `json:"stream_options,omitempty"`
	Temperature         *float64                                        `json:"temperature,omitempty"`
	ToolChoice          *ChatCompletionNonStreamingToolChoiceUnion      `json:"tool_choice,omitempty"`
	Tools               []ChatCompletionToolParam                       `json:"tools,omitempty"`
	TopLogprobs         *int64                                          `json:"top_logprobs,omitempty"`
	TopP                *float64                                        `json:"top_p,omitempty"`
	User                *string                                         `json:"user,omitempty"`
	WebSearchOptions    *WebSearchOptions                               `json:"web_search_options,omitempty"`
	stream              *bool                                           `const:"false" json:"stream,omitempty"`
	Tags                map[string]any                                  `json:"tags,omitempty"`
	ParentSpanID        *string                                         `json:"parent_span_id,omitempty"`
}

func (c ChatCompletionNonStreaming) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatCompletionNonStreaming) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ChatCompletionNonStreaming) GetMessages() []ChatCompletionNonStreamingMessage {
	if o == nil {
		return []ChatCompletionNonStreamingMessage{}
	}
	return o.Messages
}

func (o *ChatCompletionNonStreaming) GetModel() *TModel {
	if o == nil {
		return nil
	}
	return o.Model
}

func (o *ChatCompletionNonStreaming) GetAudio() *ChatCompletionAudioParam {
	if o == nil {
		return nil
	}
	return o.Audio
}

func (o *ChatCompletionNonStreaming) GetFrequencyPenalty() *float64 {
	if o == nil {
		return nil
	}
	return o.FrequencyPenalty
}

func (o *ChatCompletionNonStreaming) GetFunctionCall() *ChatCompletionNonStreamingFunctionCallUnion {
	if o == nil {
		return nil
	}
	return o.FunctionCall
}

func (o *ChatCompletionNonStreaming) GetFunctions() []OpenaiTypesChatCompletionCreateParamsFunction {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ChatCompletionNonStreaming) GetLogitBias() map[string]int64 {
	if o == nil {
		return nil
	}
	return o.LogitBias
}

func (o *ChatCompletionNonStreaming) GetLogprobs() *bool {
	if o == nil {
		return nil
	}
	return o.Logprobs
}

func (o *ChatCompletionNonStreaming) GetMaxCompletionTokens() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxCompletionTokens
}

func (o *ChatCompletionNonStreaming) GetMaxTokens() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxTokens
}

func (o *ChatCompletionNonStreaming) GetMetadata() map[string]string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *ChatCompletionNonStreaming) GetModalities() []ChatCompletionNonStreamingModality {
	if o == nil {
		return nil
	}
	return o.Modalities
}

func (o *ChatCompletionNonStreaming) GetN() *int64 {
	if o == nil {
		return nil
	}
	return o.N
}

func (o *ChatCompletionNonStreaming) GetParallelToolCalls() *bool {
	if o == nil {
		return nil
	}
	return o.ParallelToolCalls
}

func (o *ChatCompletionNonStreaming) GetPrediction() *ChatCompletionPredictionContentParam {
	if o == nil {
		return nil
	}
	return o.Prediction
}

func (o *ChatCompletionNonStreaming) GetPresencePenalty() *float64 {
	if o == nil {
		return nil
	}
	return o.PresencePenalty
}

func (o *ChatCompletionNonStreaming) GetReasoningEffort() *ChatCompletionNonStreamingReasoningEffort {
	if o == nil {
		return nil
	}
	return o.ReasoningEffort
}

func (o *ChatCompletionNonStreaming) GetResponseFormat() *ChatCompletionNonStreamingResponseFormat {
	if o == nil {
		return nil
	}
	return o.ResponseFormat
}

func (o *ChatCompletionNonStreaming) GetSeed() *int64 {
	if o == nil {
		return nil
	}
	return o.Seed
}

func (o *ChatCompletionNonStreaming) GetServiceTier() *ChatCompletionNonStreamingServiceTier {
	if o == nil {
		return nil
	}
	return o.ServiceTier
}

func (o *ChatCompletionNonStreaming) GetStop() *ChatCompletionNonStreamingStop {
	if o == nil {
		return nil
	}
	return o.Stop
}

func (o *ChatCompletionNonStreaming) GetStore() *bool {
	if o == nil {
		return nil
	}
	return o.Store
}

func (o *ChatCompletionNonStreaming) GetStreamOptions() *ChatCompletionStreamOptionsParam {
	if o == nil {
		return nil
	}
	return o.StreamOptions
}

func (o *ChatCompletionNonStreaming) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *ChatCompletionNonStreaming) GetToolChoice() *ChatCompletionNonStreamingToolChoiceUnion {
	if o == nil {
		return nil
	}
	return o.ToolChoice
}

func (o *ChatCompletionNonStreaming) GetTools() []ChatCompletionToolParam {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *ChatCompletionNonStreaming) GetTopLogprobs() *int64 {
	if o == nil {
		return nil
	}
	return o.TopLogprobs
}

func (o *ChatCompletionNonStreaming) GetTopP() *float64 {
	if o == nil {
		return nil
	}
	return o.TopP
}

func (o *ChatCompletionNonStreaming) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ChatCompletionNonStreaming) GetWebSearchOptions() *WebSearchOptions {
	if o == nil {
		return nil
	}
	return o.WebSearchOptions
}

func (o *ChatCompletionNonStreaming) GetStream() *bool {
	return types.Bool(false)
}

func (o *ChatCompletionNonStreaming) GetTags() map[string]any {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *ChatCompletionNonStreaming) GetParentSpanID() *string {
	if o == nil {
		return nil
	}
	return o.ParentSpanID
}
